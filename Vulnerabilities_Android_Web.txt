1. [android:allowBackup] flag is missing

Finding : The application manifest.xml file does not implement configuration for allowing or disallowing backups. By default it is set to true. 

Risk Description : The app allows allows anyone to backup application data via adb. It allows users who have enabled USB debugging to copy application data off of the device. This data includes sensitive information like session details of the logged in user.

Recommendation: Implement configuration in the android application’s Manifest.xml file to disallow backups. [android:allowBackup=False]

Reference: https://cwe.mitre.org/data/definitions/312.html

2. Clear text traffic is Enabled for App [android:usesCleartextTraffic=true]

Finding: The application manifest.xml file implements an insecure configuration for the traffic of the application. 

Risk Description: The applows allows  cleartext traffic leading to lack of confidentiality, authenticity, and protections against tampering; a network attacker can eavesdrop on transmitted data and also modify it without being detected.

Recommendation: Implement configuration in the android application’s Manifest.xml file to disallow clear text traffic.
[android:usesCleartextTraffic=False]

Reference: https://android-developers.googleblog.com/2016/04/protecting-against-unintentional.html

3. CORS Misconfiguration

Finding: The web application has a misconfigured CORS header to allow access to requests from any origin.

Risk Description : Websites use CORS to allow access from subdomains and trusted third parties. The email communication application allows any domain to make requests to it and access data and sensitive information to send it to the attacker controller server.

Recommendation: • It is recommended to avoid usage of dynamically generatated access control headers.
• If the above solution is not possible, rigorous testing should be done to programmatically verify the domain names.

Reference: https://cheatsheetseries.owasp.org/cheatsheets/HTML5_Security_Cheat_Sheet.html#cross-origin-resource-sharing

4. Missing rate limiting for emails

Finding: The application sends an email for every failed login attempt. There is no rate limiting implemented for the number of emails sent for failed login attempts. 

Risk Description: E-mail bombs hack may create Denial of service (DoS) conditions against your e-mail software and even network and Internet connection by taking up a large amount of bandwidth and, sometimes, requiring large amounts of storage space. 
It can also impact the reputation of the domain for sending mass emails in short time.

Recommendation: Implement rate limiting for outgoing emails as per a suitable mechanism menionted in the reference.

Reference: https://cloud.google.com/architecture/rate-limiting-strategies-techniques#techniques-enforcing-rate-limits

5. Missing rate limiting for OTP

Finding: The application sends OTP over email and phone as second factor for login attempts. There is no rate limiting implemented for the number of emails sent for login attempts.

Risk Description:  OTP bombs hack may create Denial of service (DoS) conditions against your OTP software and even network and Internet connection by taking up a large amount of bandwidth and, sometimes, requiring expensive costs for sending the OTPs. 
It can also impact the reputation of the domain for sending large number of OTPs in short time.

6. Application can be installed on an emulator

Finding: The banking application can be installed on an emulator. 

Risk Description: The application does not implement emulation detection techniques. It is possible for attackers to load the application in an emulated environment and reverse engineer the traffic and code to find vulnerabilities.

Recommendation: Implement emulator detection mechanisms in the application to not work if an emulator is detected.

Reference: https://www.cryptomathic.com/news-events/blog/app-hardening-for-mobile-banking-and-payment-apps-emulator-detection

7. Internal hostname disclosure

Finding: The application traffic discloses an internal hostname of a machine and  nomenclature of the systems used in the internal network of the organization.

Risk Description: An attacker can chain this information with other vulnerabilities to perform activities like exploitation of internal networks, lateral movement and privilege escalations. 

Recommendation: Configure the application to not disclose internal hostnames in the traffic intended for external networks.

Reference: NA

8. Insertion of Sensitive Information into Log File [Logcat]

Finding: The application logs sensitive information in the logs of the application.

Risk Description: The app logs senstive information to logs and other applications on the rooted device can access these logs for information.

Recommendation: It is recommended to not log any sensitive information in the logs of the application.

Reference: https://cwe.mitre.org/data/definitions/532.html

9. No code obfuscation

Finding: The application does not implement code obfuscation for protection against reverse engineering.

Risk Description: Mobile applications can be reverse engineered using readily available disassemblers and/or decompilers, making it easy for hackers to access and analyze the source code of your applications. Hackers can then:
      Steal intellectual property & clone applications
      Extract sensitive information & harvest credentials
      Identify vulnerabilities
      Add malicious code to apps & repackage them

Recommendation: It is recommended to implement code obfuscation techniques to protect it against reverese engineering attempts.

Code obfuscation strategies include:
      Renaming classes, fields, methods, libraries etc.
      Altering the structure of the code
      Transforming arithmetic and logical expressions
      Encryption of strings, classes etc.
      Removing certain metadata
      Hiding calls to sensitive APIs, and more
      
Reference: https://owasp.org/www-project-mobile-top-10/2016-risks/m9-reverse-engineering

10. Application can be installed on a rooted device

Finding: The application does not implement root detection mechanisms and can be installed on a rooted android device.

Risk Description: It is possible for other applications installed on a rooted device to access and modify application data and can lead to exploitation of the logged in users. In the current scenario it is possible for the other applications to hijack the stored session cookies of the logged in user to compromise the account.

Recommendation: Implement root detection mechanisms to identify if the application is installed on a rooted device and configure the application to not work in case the detection is true.

Reference: https://mobile-security.gitbook.io/masvs/security-requirements/0x15-v8-resiliency_against_reverse_engineering_requirements 
https://mobile-security.gitbook.io/mobile-security-testing-guide/android-testing-guide/0x05j-testing-resiliency-against-reverse-engineering


11. Application signed with weak signature scheme

Finding: Application is signed with v1 signature scheme, making it vulnerable to Janus vulnerability on Android 5.0-8.0, if signed only with v1 signature scheme. Applications running on Android 5.0-7.0 signed with v1, and v2/v3 scheme is also vulnerable.

Risk Description: It is possible for an attacker to get  unverified code with powerful permissions installed on the device of unsuspecting users. This vulnerability can be exploited to pass a modified clone of the banking application. The cloned application will look and behave like the original application but inject malicious behavior.

Recommendation: Sign the application using only v2 and v3 signature scheme.

Reference: https://digital.nhs.uk/cyber-alerts/2017/cc-1886
https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-13156

12. Application signed with debug certificate and debug mode enabled

Finding: Application signed with a debug certificate. 
Debug Enabled For App
[android:debuggable=true]


Risk Description: Application signed with a debug certificate. Production application must not be shipped with a debug certificate.
Debugging was enabled on the app which makes it easier for reverse engineers to hook a debugger to it. This allows dumping a stack trace and accessing debugging helper classes.

Recommendation: Sign the application using a custom self-signed certificate.

Reference: https://developer.android.com/studio/publish/app-signing
https://developer.android.com/studio/publish/preparing#turn-off-debugging

13. No SSL Pinning implemented

Finding: The application does not implement SSL Pinning for communication with the servers.

Risk Description: Application traffic not encrypted using SSL Pinning can be intercepted to access and modify in transit before reaching the server.

Recommendation: Implement SSL Pinning in the application

Reerence: https://cheatsheetseries.owasp.org/cheatsheets/Pinning_Cheat_Sheet.html

14. Information disclosure in error messages

Finding: The application's improperly handled error messages reveal information about the underlying technologies and softwares used by the application.

Risk Description: Disclosing detailed information of the errors in the application may aid an attacker to:
      1. enumerate insecure configurations in the application
      2. Modify the payloads to exploit the application based off the internal information disclosed by the errors
      3. Enumerate unpatched software which would otherwise be unknown to external users.

Recommendation:  It is recommended to implement a standard exception handling system and default create error messages, so that unexpected errors do not disclose sensitive information. In production, you should disable or limit detailed error handling for end users. There usually is no reason to show details such as debug information, stack traces, or path information.

Reference: https://cheatsheetseries.owasp.org/cheatsheets/Error_Handling_Cheat_Sheet.html

15. Server banner disclosure

Finding: The application discloses the server banner in the response header of the application providing information about the software used by the application.

Risk Description: Disclosing server software details in the headers of the application aids an attacker to enumerate the technologies and softwares used by the application and hence allowing to exploit any known vulnerabilities in the discovered technologies.

Recommendation: Disable all the unnecessary headers in the application which do not have any functional requirements.

Reference: https://cheatsheetseries.owasp.org/cheatsheets/HTTP_Headers_Cheat_Sheet.html

16. Weak SSL Implementation

Finding: The web server supports encryption through TLS 1.1, which was formally deprecated in March 2021 as a result of inherent security issues.

Risk Description: TLS 1.0 and 1.1 are vulnerable to downgrade attacks since they rely on SHA-1 hash for the integrity of exchanged messages. Even authentication of handshakes is done based on SHA-1, which makes it easier for an attacker to impersonate a server for MITM attacks. TLS 1.1 or below does not provide the option to select more robust hashing algorithms, which the newer protocols do.

Recommendation: Implement secure TLS 1.2 or 1.3 with only cryptographically strong and secure ciphers enabled.

Reference: https://cheatsheetseries.owasp.org/cheatsheets/Transport_Layer_Protection_Cheat_Sheet.html

17. Google API key disclosure

Finding: The application discloses google maps api key in the HTML source code of the application.

Risk Description: Unauthorized Usage: If someone maliciously obtains your Google Maps API key, they could use it to make requests on their own websites or applications, potentially leading to large volumes of unexpected traffic. This could lead to a significant increase in usage costs for you.

      Service Quota Exhaustion: Google Maps API has a usage limit, and if someone else uses your API key, they could exhaust your quota, causing the service to be unavailable for your application until the quota is reset.

      Data Manipulation: If someone obtains your API key, they might be able to use it to alter the data associated with your Google Maps API services. For example, if you're using a service that allows data modification through the API, they might be able to alter that data.

      Billing Surprises: If the unauthorized usage goes unnoticed for a while, you may suddenly face a large, unexpected bill from Google.

      Spoofing: An attacker could potentially use your API key to spoof your application, creating a clone that looks like your site but serves their own content.

Recommendation: Server-side Proxy: Create a server-side application that makes API calls on behalf of your client-side application. The client sends a request to your server, your server adds the API key and sends the request to the external API, then returns the response to the client. This way, the API key is never exposed to the client.

      Environment Variables: If you're using a platform like Node.js, you can store your API keys in environment variables on the server, and access them in your code using process.env.YOUR_VARIABLE. This is a common practice for protecting sensitive information. However, this only works for server-side JavaScript, not client-side JavaScript.

      Obfuscation: Although this won't provide true security, obfuscating your code can make it harder (though not impossible) for someone to find your API key. This is more of a deterrence than a real security measure.

      CORS and Key Restrictions: Most API providers allow you to restrict how your API key can be used. For example, with Google APIs, you can restrict your API key to only work with certain IP addresses, referrers, or apps. This can prevent unauthorized use even if someone else gets your API key.

      Web Application Firewalls and Security Measures: Services like Cloudflare provide a firewall that can potentially prevent unauthorized access to your keys.

18. Unrestricted File Upload

Finding: The application allows the user to upload any type of file in the application using the file upload functionality.

Risk Description: 

      Malware Injection: Attackers may upload malicious files, such as viruses, worms, or trojans, disguised as harmless files. These files can infect the server or other user systems, compromising their security and integrity.

      Remote Code Execution: If the uploaded files are executed on the server, attackers can exploit vulnerabilities in the file processing mechanism to execute arbitrary code. This can lead to unauthorized access, data breaches, and complete system compromise.

      Denial of Service (DoS): Attackers can upload large, resource-intensive files that can consume excessive server resources, leading to a denial of service for legitimate users. This can result in system slowdowns, unavailability, or even complete system crashes.

Recommendation: 
      List allowed extensions. Only allow safe and critical extensions for business functionality
      Ensure that input validation is applied before validating the extensions.
      Validate the file type, don't trust the Content-Type header as it can be spoofed
      Change the filename to something generated by the application
      Set a filename length limit. Restrict the allowed characters if possible
      Set a file size limit
      Only allow authorized users to upload files

Reference: https://cheatsheetseries.owasp.org/cheatsheets/File_Upload_Cheat_Sheet.html

19. Internal service exposure

Finding: The api end-point accepts traffic on port 80 and then internally redirects it to port 9443. The port 9443 is exposed to the network and can be used for communication directly.

Risk Description:

An attacker can fingerprint the internal workings of the application and discover vulnerabilities for exploitation. Exposing internal services also may have the following risks:
•	Unnecessary bruteforce attacks
•	Exploitation of unpatched software
•	Exploitation of unsafe configuration
•	Denial of service
•	Leaking information

Recommendation: 
•	Implement the service on localhost network – 127.0.0.1
•	Implement firewall rules to only allow traffic from / to specified Ips if above solution is not possible

References:
      https://cheatsheetseries.owasp.org/cheatsheets/Microservices_Security_Cheat_Sheet.html

20. Host header injeciton

Finding: It is observed that the web application processes the host header set by the client in a web request to perform the operations like redirections.  

Risk Description:
   A  web server commonly hosts several applications on the same IP address, referring to each application via the virtual host. In an incoming HTTP request, web servers often dispatch the request to the target virtual host based on the value supplied in the Host header. Without proper validation of the header value, the attacker can supply invalid input to cause the web server to perform actions such as, dispatching requests to the first virtual host on the list, redirecting to attackers application, and poisoning the web cache and manipulating password reset links.

Recommendation:
      Recommendation	It is recommended that the application should not trust headers like Host and X-Forwarded-Host that are set by the client and should use a secure SERVER_NAME set on the server side instead of similar headers.

References:
      https://portswigger.net/web-security/host-header/exploiting
      https://cheatsheetseries.owasp.org/cheatsheets/HTTP_Headers_Cheat_Sheet.html

21. Javascript enabled for webviews

Finding: The android application has enabled javascript for the webview components of the application.

Risk Description: 
      WebView is a component that allows you to display web content within your Android app, essentially embedding a web browser within your app. Below are some of the risks associated with enabling JavaScript in WebView:
•	Cross-Site Scripting (XSS): If not properly sanitized, JavaScript code in WebView can introduce vulnerabilities like XSS, where an attacker can inject malicious scripts into the WebView content, potentially stealing user data or performing other malicious actions.
•	Content Spoofing: Attackers might load fake content or phishing pages within WebView to deceive users into thinking they're interacting with a legitimate website.
•	Data Leakage: JavaScript in WebView could potentially access sensitive information stored in the app's local storage, cookies, or other session data.
•	Drive-By Downloads: Malicious JavaScript could attempt to download and install harmful software onto the user's device.


Recommendation:
      •	Disable the javascript in webview settings if not necessary
      •	If required –
      Ensure that input from external sources is properly validated and sanitized to prevent injection attacks like XSS.
      Implement a CSP to define which sources of scripts, styles, and other resources are allowed to be executed within the WebView.

References:
      https://mas.owasp.org/MASTG/Android/0x05h-Testing-Platform-Interaction/#javascript-execution-in-webviews

22: Broken Access Control in View Fund Balance

Finding: The application does not implement access control over the account numbers of the application and allows any user to view fund balance of other users of the application.

Risk Description: This may allow any authenticated user on the application to access and download case related files and documents of other users in the application
•	Customer data (name, email, address, QID etc)
•	Case related documents
Further, public disclosure of this data might lead to privacy concerns and negatively impact the organization’s reputation. 

Recommendation: It is recommended to implement robust authentication and authorization mechanisms to ensure that logged-in users’ privileges are ascertained through a session or authentication token before granting access to sensitive information or functionalities. This needs to be implemented across all pages and functionalities of the application.

23. JWT Token not invalidated after logout

Finding: The JWT token in use for authentication by the application is not invalidated after the user has log out of the application.

Risk Description: An attacker having compromised any tokens of a user will be able to access the resources and accessible sensitive data of the user for a long period of time. 

Recommendation: It is recommended to implement a token block list that will be used to mimic the "logout" feature that exists with traditional session management system.

Reference: https://cheatsheetseries.owasp.org/cheatsheets/JSON_Web_Token_for_Java_Cheat_Sheet.html#token-explicit-revocation-by-the-user

















